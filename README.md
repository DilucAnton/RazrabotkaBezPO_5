# RazrabotkaBezPO_5


Установка ubuntu: 


<img width="788" alt="Снимок экрана 2024-12-22 в 01 26 14" src="https://github.com/user-attachments/assets/aa9dad66-97f3-45c5-8e9c-06e7ca51bdee" />


Создаем директорию и файл с уязвимым кодом:
<img width="490" alt="Снимок экрана 2024-12-22 в 01 28 00" src="https://github.com/user-attachments/assets/d133f08b-4ab2-4348-be87-42e2a1937bb5" />

Вставляем уязвимый код:
<img width="792" alt="Снимок экрана 2024-12-22 в 01 27 38" src="https://github.com/user-attachments/assets/5564098b-8be1-4269-9d16-a5c0add7f104" />

Компилируем программу с отключенными защитами:

gcc -fno-stack-protector -z execstack -o vulnerable vulnerable.c
-fno-stack-protector отключает защиту от переполнения буфера
-z execstack делает стек исполняемым

<img width="733" alt="Снимок экрана 2024-12-22 в 01 28 51" src="https://github.com/user-attachments/assets/b79cf34d-6996-40d6-95af-6009fc689c24" />



Запускаем программу в отладчике gdb:

<img width="681" alt="Снимок экрана 2024-12-22 в 01 29 47" src="https://github.com/user-attachments/assets/ed0fa2bb-b591-415c-a834-5087e7d91d66" />




<img width="624" alt="Снимок экрана 2024-12-22 в 01 30 34" src="https://github.com/user-attachments/assets/b994e318-0de3-4fa2-907a-77e787d7c357" />


<img width="525" alt="Снимок экрана 2024-12-22 в 01 31 01" src="https://github.com/user-attachments/assets/b5bf38a0-ffc1-4aa0-9812-154cbcba871f" />


Анализируем стек
<img width="468" alt="Снимок экрана 2024-12-22 в 01 44 30" src="https://github.com/user-attachments/assets/0a2b565e-d5dd-4639-a030-70a7d1630cc7" />

Содержимое стека

<img width="643" alt="Снимок экрана 2024-12-22 в 01 44 50" src="https://github.com/user-attachments/assets/02026012-71db-4450-a70d-5805d7cdc3b0" />

Уязвимость переполнения буфера возникает в функции `main`, где буфер `buf[128]` заполняется вводом с использованием функции `fgets`, которая считывает до 133 символов. Это позволяет злоумышленнику перезаписать адрес возврата, расположенный в стеке, после `buf[128]`.
Функция `shell` находится по адресу 0x0000aaaaaaaa0884. Она вызывает системный вызов `system("/bin/bash")`, который открывает оболочку bash. Адрес этой функции используется для эксплуатации уязвимости.
Анализ стека показал, что буфер `buf[128]` расположен в начале локальных переменных. Адрес возврата находится сразу после буфера, на смещении 136 байт. Это позволяет перезаписать адрес возврата, направив выполнение программы на функцию `shell`.
С помощью Python была сгенерирована строка для эксплуатации уязвимости:
bash
python3 -c 'print("A" * 136 + "\x84\x08\x00\x00\x00\x00\x00\x00")' | ./vulnerable
Для предотвращения уязвимости был использован исправленный код, в котором длина ввода ограничивается с помощью функции `fgets`:
c
fgets(buf, sizeof(buf), stdin);

Исправление уязвимости
Для предотвращения уязвимости был использован исправленный код. Проблема переполнения буфера устранена с помощью ограничения ввода, которое соответствует размеру буфера. Исправленный код выглядит следующим образом

<img width="811" alt="Снимок экрана 2024-12-22 в 01 51 19" src="https://github.com/user-attachments/assets/496aef32-805d-432e-9490-f8de1cca7eaf" />

Вывод
В уязвимой версии программы была выявлена ошибка переполнения буфера, которая позволяла злоумышленнику перезаписать адрес возврата и перенаправить выполнение программы на функцию shell.
Проблема была воспроизведена с помощью отладчика gdb и строки-эксплойта, сгенерированной на Python.
Для устранения уязвимости код был исправлен. Теперь ввод ограничивается размером буфера с помощью fgets.
Исправленный код был проверен на устойчивость к длинному вводу, и проблема переполнения буфера была устранена.

![Uploading Снимок экрана 2024-12-22 в 01.53.02.png…]()


